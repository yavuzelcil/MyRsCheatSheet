\documentclass[8pt,a4paper,twocolumn]{extarticle}

% Encoding and language
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage[shorthands=off,turkish]{babel}

% Page geometry and columns
\usepackage{geometry}
\geometry{top=10mm,bottom=12mm,left=10mm,right=10mm}
\setlength{\columnsep}{8mm}
\setlength{\columnseprule}{0.2pt}

% Fonts and micro-typography
\usepackage{lmodern}
\usepackage{iftex}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{tikz}
% microtype: enable font expansion only on pdfTeX
\ifPDFTeX
  \usepackage[protrusion=true,expansion=true]{microtype}
\else
  \usepackage[protrusion=true,expansion=false]{microtype}
\fi

% Spacing and lists
\usepackage{parskip}
\setlength{\parskip}{2pt}
\setlength{\parindent}{0pt}
\usepackage{enumitem}
\setlist{nosep,leftmargin=4mm}

% Headings
\usepackage{titlesec}
\titlespacing*{\section}{0pt}{4pt}{2pt}
\titlespacing*{\subsection}{0pt}{3pt}{1pt}
\titlespacing*{\subsubsection}{0pt}{2pt}{0.5pt}

% Header/footer
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{MyRs Cheat Sheet}
\rhead{\thepage}
\renewcommand{\headrulewidth}{0.2pt}

% Links
\usepackage[hidelinks]{hyperref}

% Code listings (ASCII content for portability)
\usepackage{xcolor}
\usepackage{listings}
% Colors for code
\definecolor{codekw}{RGB}{0,92,197}
\definecolor{codecmt}{gray}{0.35}
\definecolor{codestr}{RGB}{26,127,55}
\lstset{
  basicstyle=\ttfamily\scriptsize,
  keywordstyle=\bfseries\color{codekw},
  commentstyle=\itshape\color{codecmt},
  stringstyle=\color{codestr},
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  upquote=true,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
}
% Define a thin wrapper for listings. Note: do not wrap verbatim
% environments (like lstlisting) inside \newenvironment.
\lstnewenvironment{Code}{}{}

% Hugging Face emoji using TikZ
\newcommand{\huggingface}{%
  \begin{tikzpicture}[baseline=-0.3ex, scale=0.15]
    % Face circle
    \draw[fill=yellow!80, draw=orange!80, line width=0.3pt] (0,0) circle (1);
    % Eyes
    \fill (0.35,0.3) circle (0.15);
    \fill (-0.35,0.3) circle (0.15);
    % Smile
    \draw[line width=0.15pt] (-0.4,-0.15) .. controls (-0.2,-0.45) and (0.2,-0.45) .. (0.4,-0.15);
  \end{tikzpicture}%
}

\begin{document}

% Title
\begin{center}
{\Large MyRs Cheat Sheet \huggingface}\\
{\footnotesize Quick Reference --- Draft v1.0 (\today)}
\end{center}

\vspace{2mm}

% Intro note
{\footnotesize This template sets up a compact, two-column A4 layout. Listings are configured for small print and good readability.}

\section{Cargo Quick Commands}
\begin{itemize}
  \item \texttt{cargo new myproj} -- Create new binary project
  \item \texttt{cargo new --lib mylib} -- Create new library crate
  \item \texttt{cargo new --bin myproj} -- Create new binary project
  \item \texttt{cargo add <crate>} -- Add dependency
  \item \texttt{cargo check} -- Check code without building
  \item \texttt{cargo clippy} -- Lint code
  \item \texttt{cargo doc --open} -- Generate and open docs
  \item \texttt{cargo run} -- Build and run
  \item \texttt{cargo run --quiet} -- Quiet run
  \item \texttt{cargo build --release} -- Optimized build
  \item \texttt{cargo build --quiet} -- Quiet build
  \item \texttt{cargo clean} -- Remove build artifacts
  \item \texttt{cargo bench} -- Run benchmarks
  \item \texttt{cargo test} -- Run tests
  \item \texttt{cargo fmt} -- Format code
\end{itemize}

\section{Hello, world! (Rust)}

\textbf{Create and compile with bash:}
\begin{Code}
# Create file
touch main.rs
\end{Code}
\textbf{Rust code:}
\begin{Code}
fn main() {
    println!("Hello, world!");
}
\end{Code}
\begin{Code}
# Compile with rustc
rustc main.rs

# Run the binary
./main
\end{Code}



\subsection{File Naming Convention}
\begin{itemize}
  \item \textcolor{green}{\ding{51}} \texttt{hello\_world.rs} -- Correct: snake\_case
  \item \textcolor{red}{\ding{55}} \texttt{helloworld.rs} -- Wrong: no separator
\end{itemize}

\section{Variables and Types}
\begin{Code}
fn main() {

    // Scalar types: 

    let decimal: i32 = 98_222;      // Integer
    let hex: i32 = 0xff;            // Hexadecimal
    let octal: i32 = 0o77;          // Octal
    let binary: i32 = 0b1111_0000;  // Binary
    let byte: u8 = b'A';            // Byte (u8)
    let character: char = 'R';      // Character
    %let hugging_face: char = 'ðŸ¤—'; // Unicode character

    //Compound types:

    let tuple: (i32, f64, u8) = (500, 6.4, 1);
    let (a, b, c) = tuple;
    let array: [i32; 4] = [1, 2, 3, 4];
    let first = array[0];

    // Constants:
    const MAX_POINTS: u32 = 100_000;

}
\end{Code}
\subsection{Mutability}
\begin{Code}
fn main() {
    let x = 5;     // immutable variable by default
    println!("Initial x: {}", x); // 5
    // x = x + 1;  // error: cannot assign twice to immutable variable

    let mut x = 5; // mutable variable
    println!("Initial x: {}", x); // 5
    x = x + 1;     // modify x
    println!("Modified x: {}", x); // 6
}
\end{Code}

\subsection{Shadowing}
\begin{Code}
fn main() {
    let x = 5;
    let x = x + 1; // shadows previous x
    {
        let x = x * 2; // shadows again in inner scope
        println!("Inner x: {}", x); // 12
    }
    println!("Outer x: {}", x); // 6
}
\end{Code}
\subsubsection{Shadowing vs Mutability}
\begin{Code}
fn main() {
    // using mutability
    let mut x = 5;
    x = x + 1; // modify x
    println!("Mutable x: {}", x); // 6
    // using shadowing
    let x = 5;
    let x = x + 1; // shadow previous x
    println!("Shadowed x: {}", x); // 6
}
\end{Code}
\section{Macros}
\subsection{Declarative Macros}
\begin{Code}
macro_rules! greet {
    ($name:expr) => {
        println!("Hello, {}!", $name);
    };
}
fn main() {
    greet!("Alice"); // Hello, Alice!
    greet!("Bob");   // Hello, Bob!
}
\end{Code}

\subsection{Procedural Macros}

Procedural macros work on the abstract syntax tree (AST) of Rust code.

\textbf{Types:}
\begin{itemize}
  \item \textbf{Derive macros:} \texttt{\#[derive(MyTrait)]}
  \item \textbf{Attribute macros:} \texttt{\#[my\_attribute]}
  \item \textbf{Function-like macros:} \texttt{my\_macro!(input)}
\end{itemize}

\textbf{Example: Custom Derive Macro}
\begin{Code}
// In Cargo.toml:
// [lib]
// proc-macro = true

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let name = &ast.ident;
    
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello from {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
\end{Code}

\textbf{Usage:}
\begin{Code}
trait HelloMacro {
    fn hello_macro();
}

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro(); // Hello from Pancakes!
}
\end{Code}

\section{Control Flow}
\begin{Code}
fn main() {
    let number = 6;
    if number % 2 == 0 {
        println!("{} is even", number);
    } else {
        println!("{} is odd", number);
    }
}
\end{Code}

\subsection{Combining Conditions}
\begin{Code}
fn main() {
    let number = 6;
    if number > 0 && number % 2 == 0 {
        println!("{} is a positive even number", number);
    } else if number > 0 && number % 2 != 0 {
        println!("{} is a positive odd number", number);
    } else {
        println!("{} is not positive", number);
    }
}
\end{Code}

\textbf{OR || operator}
\begin{Code}
fn main() {
    let number = 6;
    if number > 0 || number % 2 == 0 {
        println!("{} is a positive even number", number);
    } else if number > 0 || number % 2 != 0 {
        println!("{} is a positive odd number", number);
    } else {
        println!("{} is not positive", number);
    }
}
\end{Code}

\subsection{Basic Loop}
\begin{Code}
fn main() {
    let mut count = 0;
    loop {  
        count += 1;
        if count == 5 {
            break;
        }
        println!("Count: {}", count);
    }
}
\end{Code}
\subsubsection{Loop Labels}
\begin{Code}
fn main() {
    let mut count = 0;
    'outer: loop {
        count += 1;
        let mut inner_count = 0;
        loop {
            inner_count += 1;
            if inner_count == 3 {
                break 'outer; // breaks the outer loop
            }
            println!("Inner Count: {}", inner_count);
        }
        println!("Count: {}", count);
    }
}
\end{Code}

\section{For and While}
\begin{Code}
fn main() {
    let numbers = [10, 20, 30, 40, 50];
    for n in numbers.iter() {
        println!("Number: {}", n);
    }
}
\end{Code}
\begin{Code}
fn main() {
    let mut count = 0;
    while count < 5 {
        println!("Count: {}", count);
        count += 1;
    }
}
\end{Code}

\subsection {Range in For Loop}
\begin{Code}
fn main() {
    for i in 1..=5 { // inclusive range
        println!("i: {}", i);
    }
}
\end{Code}

\subsection{Break and Continue}
\begin{Code}
fn main() {
    for i in 1..10 {
        if i % 2 == 0 {
            continue; // skip even numbers
        }
        if i > 7 {
            break; // exit loop if i > 7
        }
        println!("Odd i: {}", i);
    }
}
\end{Code}

\section{Pattern Matching}
\begin{Code}
fn main() {
    let number = 3;
    match number {
        1 => println!("One"),
        2 => println!("Two"),
        3 | 4 | 5 => println!("Three, Four, or Five"),
        _ => println!("Something else"),
    }
}
\end{Code}

\textbf{Or | operator}
\begin{Code}
fn main() {
    let x = 2;
    match x {
        1 | 3 | 5 => println!("Odd"),
        2 | 4 => println!("Even"),
        _ => println!("Something else"),
    }
}
\end{Code}
\textbf{Matching Ranges}
\begin{Code}
fn main() {
    let x = 5;
    match x {
        1..=5 => println!("In range 1 to 5"),
        _ => println!("Out of range"),
    }
}
\end{Code}

\textbf{Ignoring Values with \_}
\begin{Code}
fn main() {
    let point = (3, 5);
    match point {
        (x, _) => println!("x is {}, y is ignored", x),
    }
}
\end{Code}

\section{Functions}
\begin{Code}
    fn greet(name: &str) {
        println!("Hello, {}!", name);
    }
    fn main() {
        greet("Alice");
        greet("Bob");
    } 
\end{Code}  
\subsection{Functions with Return Values}
\begin{Code}
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    fn main() {
        let sum = add(5, 10);
        println!("Sum: {}", sum);
    }
\end{Code}

\section{Statements and Expressions}
\begin{Code}
fn main() {
    let x = 5; // statement
    let y = {
        let z = 10; // statement
        z + 5      // expression
    }; // expression

    println!("x: {}, y: {}", x, y);
}
\end{Code}

\textbf{If as an Expression}
\begin{Code}
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 10 }; // if expression
    println!("The number is: {}", number);
}
\end{Code}

\textbf{match as an Expression}
\begin{Code}
fn main() {
    let number = 3;
    let result = match number {
        1 => "One",
        2 => "Two",
        3 => "Three",
        _ => "Something else",
    }; // match expression
    println!("The result is: {}", result);
}
\end{Code}


\section{Ownership and Borrowing}
\begin{Code}
fn main() {
    let s1 = String::from("hello"); // s1 owns the string
    let s2 = s1;                    // ownership moved to s2
    // println!("{}", s1);          // error: s1 is no longer valid

    let s3 = String::from("world");
    let s4 = &s3;                   // borrow s3
    println!("s3: {}, s4: {}", s3, s4); // both valid
}// s3 and s4 go out of scope here
\end{Code}

\subsection{Stack and Heap}
\begin{itemize}
  \item \textbf{Stack:} Fast, fixed-size data. FiFo structure.
  \item \textbf{Heap:} Dynamic-size data. Slower access due to indirection.
\end{itemize}
\begin{Code}
fn main() {
    let x = 5;              // stored on stack
    let s1 = String::from("hello"); // stored on heap
    let s2 = s1;           // ownership moved to s2
    // println!("{}", s1);  // error: s1 is no longer valid
    println!("x: {}, s2: {}", x, s2);
} // x and s2 go out of scope here and memory is freed

\section{Result and Error Handling}
\begin{Code}
use std::fs::File;
use std::io::{self, Read};

fn read_path(path: &str) -> io::Result<String> {
    let mut s = String::new();
    File::open(path)?.read_to_string(&mut s)?;
    Ok(s)
}
\end{Code}

\section{Vector and Match}
\begin{Code}
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    for n in &numbers { println!("{n}"); }

    match numbers.get(10) {
        Some(x) => println!("found: {x}"),
        None => println!("none"),
    }
}
\end{Code}

\section{Trait and Impl}
\begin{Code}
trait Area { fn area(&self) -> f64; }

struct Circle { r: f64 }

impl Area for Circle {
    fn area(&self) -> f64 { std::f64::consts::PI * self.r * self.r }
}

fn main() {
    let c = Circle { r: 2.0 };
    println!("area = {}", c.area());
}
\end{Code}


\section{Creating Custom Error Types}

\begin{Code}
use std::fmt;

#[derive(Debug)]
enum MyError {
  NotFound,
  InvalidInput,
  ConnectionError,
}

impl fmt::Display for MyError {
  fn fmt(&self, f: &mut fmt::Firmatter) -> fmt::Result {
    match self {
      MyError::NotFound => write!(f, "Resource not found"),
      MyError::InvalidInput => write!(f, "Invalid input provided"),
      MyError::ConnectionError => write!(f, "Connection error occurred"),
    }
  }
}
\end{Code}


\section{Logging}

The `log` crate provides a lightweight logging facade. To use it:

\begin{Code}
use log::{info, warn, error, debug};

fn main() {
    env_logger::init();
    info!("Starting application");^
    warn!("Low disk space");
    error!("Failed to connect to database");
    debug!("Debugging information");
}
\end{Code}

The slog crate is another popular logging library that provides more features and flexibility.

\begin{Code}
use slog::{Drain, Logger, o, info};
use slog_async;
use slog_term;

fn main() {
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::CompactFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let log = Logger::root(drain, o!());

    info!(log, "Application started");
}
\end{Code}

\section{Quick Notes}
\begin{itemize}
  \item \textbf{Docs/Help:} \texttt{rustup doc} and \texttt{cargo --help}.
  \item \textbf{Format:} \texttt{rustfmt} (automatic). \textbf{Lint:} \texttt{clippy}.
  \item \textbf{Toolchains:} \texttt{rustup toolchain list}, \texttt{rustup override}.
  \item \textbf{Tests:} \texttt{\#[test]} and \texttt{cargo test -q}.
  \item \textbf{Performance:} build with \texttt{--release}, \texttt{cargo bench} (nightly).
\end{itemize}

% Now, I m writing my own cheatsheet content below

\section{Generics}

\subsection{Generic functions}

\begin{Code}

  fn first_element<T>(list: &[T]) -> Option<&T> {
      if list.is_empty() {
          None
      } else {
          Some(&list[0])
      }
  }

  fn main() {
      let numbers = vec![1, 2, 3];
      let words = vec!["hello", "world"];
      
      if let Some(first_num) = first_element(&numbers) {
          println!("First number: {}", first_num);
      }
      
      if let Some(first_word) = first_element(&words) {
          println!("First word: {}", first_word);
      }
  }
\end{Code}

\subsection{Generic structs}

\begin{Code}
  struct Point<T> {
      x: T,
      y: T,
      z: i32,
  }

  impl<T> Point<T> {
      fn new(x: T, y: T, z: i32) -> Self {
          Point { x, y, z }
      }
  }

  fn main() {
      let int_point = Point::new(1, 2, 3);
      let float_point = Point::new(1.0, 2.0, 3.0);
      
      println!("Integer Point: ({}, {}, {})", int_point.x, int_point.y, int_point.z);
      println!("Float Point: ({}, {}, {})", float_point.x, float_point.y, float_point.z);
  }
\end{Code}

\subsection{Generic Enums}

\begin{Code}
  enum Option<T> {
      Some(T),
      None,
  }

  fn main() {
      let some_number = Option::Some(5);
      let no_number: Option<i32> = Option::None;
      
      match some_number {
          Option::Some(value) => println!("Got a number: {}", value),
          Option::None => println!("No number"),
      }
      
      match no_number {
          Option::Some(value) => println!("Got a number: {}", value),
          Option::None => println!("No number"),
      }
  }
\end{Code}

\subsection{Notes:}
\begin{itemize}
  \item Using generics doesnt slow down your code. The compiler generates optimized versions for each type used.
  \item Monomorphization is the process of generating specific implementations for each type used with generics.
  \item Monomorphization happens at compile time, so there is no runtime overhead.
\end{itemize}



\section{Traits}

\begin{itemize}
  \item Traits define shared behavior across types.
  \item A trait is like a contract that types can implement.
  \item Traits enable polymorphism and code reuse.
\end{itemize}

\subsection{Defining and Implementing Traits}
\begin{Code}
  pub trait Summary {
      fn summarize(&self) -> String {
          String::from("(Read more...)") // default implementation
      }
  }

  struct NewsArticle {
      headline: String,
      location: String,
      content: String,
  }

  impl Summary for NewsArticle {
      fn summarize(&self) -> String {
          format!("{} - {}", self.headline, self.location)
      }
  }
  struct Tweet {
      username: String,
      content: String,
      reply: bool,
      retweet: bool,
  }
  impl Summary for Tweet {
      fn summarize(&self) -> String {
          format!("{}: {}", self.username, self.content)
      }
  }
  fn main() {
      let article = NewsArticle {
          headline: String::from("Rust is awesome!"),
          location: String::from("Internet"),
          content: String::from("Rust is a systems programming language..."),
      };
      let tweet = Tweet {
          username: String::from("user123"),
          content: String::from("Hello, world!"),
          reply: false,
          retweet: false,
      };
      println!("Article Summary: {}", article.summarize());
      println!("Tweet Summary: {}", tweet.summarize());
  }
\end{Code}

\subsubsection{Polymorphism}

A function that accepts any type implementing a trait.
Using traits as function parameters:

\begin{Code}
  fn notify(item: &impl Summary) {
      println!("Breaking news! {}", item.summarize());
  }

  fn main() {
      let article = NewsArticle {
          headline: String::from("Rust is awesome!"),
          location: String::from("Internet"),
          content: String::from("Rust is a systems programming language..."),
      };
      let tweet = Tweet {
          username: String::from("user123"),
          content: String::from("Hello, world!"),
          reply: false,
          retweet: false,
      };
      notify(&article);
      notify(&tweet);
  }
\end{Code}

\subsubsection{Trait Bounds and Generics}

Using trait bounds in generic functions:
\begin{Code}
  fn notify<T: Summary>(item: &T) {
      println!("Breaking news! {}", item.summarize());
  }
\end{Code}


\section{Lifetimes}


Lifetimes manage how long references are valid to prevent dangling references.

\begin{itemize}
    \item Ensure references do not outlive the data they point to.
    \item Specified using apostrophes (e.g., \texttt{'a}).
    \item Prevents references from pointing to invalid data.
\end{itemize}

\begin{Code}
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    
    fn main() {
        let string1 = String::from("long string");
        let string2 = "short";
    
        let result = longest(string1.as_str(), string2);
        println!("The longest string is {}", result);
    }
\end{Code}
\subsection{Lifetime Annotations in Structs}
\begin{Code}
    struct ImportantExcerpt<'a> {
        part: &'a str,
    }
    
    fn main() {
        let novel = String::from("Call me Ishmael. Some years ago...");
        let first_sentence = novel.split('.').next().expect("Could not find a '.'");
        let excerpt = ImportantExcerpt { part: first_sentence };
        println!("Excerpt: {}", excerpt.part);
    }
\end{Code}

\subsubsection{Lifetime Elision}
Rust applies three rules to infer lifetimes when they are not explicitly annotated:
\begin{itemize}
    \item Each parameter that is a reference gets its own lifetime parameter.
    \item If there is exactly one input lifetime parameter, that lifetime is assigned to all output
    reference parameters.
    \item If there are multiple input lifetime parameters, but one of them is \texttt{\&self} or \texttt{\&mut self}, the lifetime of \texttt{self} is assigned to all output reference parameters.
\end{itemize}
\begin{Code}
    fn first_word(s: &str) -> &str {
        let bytes = s.as_bytes();
    
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &s[0..i];
            }
        }
    
        &s[..]
    }
\end{Code}

\subsubsection{Static Lifetimes}

Static lifetimes are the longest possible lifetimes in Rust. They last for the entire duration of the program. They are stored in the binary's read-only memory.

\begin{Code}
    fn main() {

        // A string literal has a 'static lifetime
        let s: &'static str = "I have a static lifetime.";


        // Global variable with 'static lifetime
        static GLOBAL_VAR: &str = "I am a global variable with a static lifetime.";

    }
\end{Code}

\section{Smart Pointers}
Smart pointers are data structures that not only act like a pointer but also have additional metadata and capabilities.

Single ownership with Box<T>:
\begin{Code}
    fn main() {
        let b = Box::new(5);
        println!("b = {}", b);
    }
\end{Code}

Shared ownership with Rc<T>:
\begin{Code}
    use std::rc::Rc;

    fn main() {
        let a = Rc::new(5);
        let b = Rc::clone(&a);
        println!("a = {}, b = {}", a, b);
    }
\end{Code}




\end{document}
