\documentclass[8pt,a4paper,twocolumn]{extarticle}

% Encoding and language
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage[shorthands=off,turkish]{babel}

% Page geometry and columns
\usepackage{geometry}
\geometry{top=10mm,bottom=12mm,left=10mm,right=10mm}
\setlength{\columnsep}{8mm}
\setlength{\columnseprule}{0.2pt}

% Fonts and micro-typography
\usepackage{lmodern}
\usepackage{iftex}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{tikz}
% microtype: enable font expansion only on pdfTeX
\ifPDFTeX
  \usepackage[protrusion=true,expansion=true]{microtype}
\else
  \usepackage[protrusion=true,expansion=false]{microtype}
\fi

% Spacing and lists
\usepackage{parskip}
\setlength{\parskip}{2pt}
\setlength{\parindent}{0pt}
\usepackage{enumitem}
\setlist{nosep,leftmargin=4mm}

% Headings
\usepackage{titlesec}
\titleformat{\part}[block]{\Large\bfseries\centering\color{blue!80!black}}{\thepart}{0.5em}{}
\titlespacing*{\part}{0pt}{8pt}{4pt}
\titlespacing*{\section}{0pt}{4pt}{2pt}
\titlespacing*{\subsection}{0pt}{3pt}{1pt}
\titlespacing*{\subsubsection}{0pt}{2pt}{0.5pt}

% Header/footer
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{MyRs Cheat Sheet}
\rhead{\thepage}
\renewcommand{\headrulewidth}{0.2pt}

% Links
\usepackage[hidelinks]{hyperref}

% Code listings (ASCII content for portability)
\usepackage{xcolor}
\usepackage{listings}
% Colors for code
\definecolor{codekw}{RGB}{0,92,197}
\definecolor{codecmt}{gray}{0.35}
\definecolor{codestr}{RGB}{26,127,55}
\lstset{
  basicstyle=\ttfamily\scriptsize,
  keywordstyle=\bfseries\color{codekw},
  commentstyle=\itshape\color{codecmt},
  stringstyle=\color{codestr},
  columns=fullflexible,
  keepspaces=true,
  showstringspaces=false,
  upquote=true,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
}
% Define a thin wrapper for listings. Note: do not wrap verbatim
% environments (like lstlisting) inside \newenvironment.
\lstnewenvironment{Code}{}{}

% Hugging Face emoji using TikZ
\newcommand{\huggingface}{%
  \begin{tikzpicture}[baseline=-0.3ex, scale=0.15]
    % Face circle
    \draw[fill=yellow!80, draw=orange!80, line width=0.3pt] (0,0) circle (1);
    % Eyes
    \fill (0.35,0.3) circle (0.15);
    \fill (-0.35,0.3) circle (0.15);
    % Smile
    \draw[line width=0.15pt] (-0.4,-0.15) .. controls (-0.2,-0.45) and (0.2,-0.45) .. (0.4,-0.15);
  \end{tikzpicture}%
}

\begin{document}

% Title
\begin{center}
{\Large MyRs Cheat Sheet \huggingface}\\
{\footnotesize Quick Reference --- Draft v1.0 (\today)}
\end{center}

\vspace{2mm}

% Intro note
{\footnotesize This template sets up a compact, two-column A4 layout. Listings are configured for small print and good readability.}

\part{RUST BASICS}

\section{Cargo Quick Commands}
\begin{itemize}
  \item \texttt{cargo new myproj} -- Create new binary project
  \item \texttt{cargo new ---lib mylib} -- Create new library crate
  \item \texttt{cargo new ---bin myproj} -- Create new binary project
  \item \texttt{cargo add <crate>} -- Add dependency
  \item \texttt{cargo add ---dev <crate>} -- Add dev-dependency
  \item \texttt{cargo add <crate> ---features <features>} -- Add crate with features
  \item \texttt{cargo check} -- Check code without building
  \item \texttt{cargo clippy} -- Lint code
  \item \texttt{cargo doc ---open} -- Generate and open docs
  \item \texttt{cargo run} -- Build and run
  \item \texttt{cargo run ---quiet} -- Quiet run
  \item \texttt{cargo build ---release} -- Optimized build
  \item \texttt{cargo build ---quiet} -- Quiet build
  \item \texttt{cargo clean} -- Remove build artifacts
  \item \texttt{cargo bench} -- Run benchmarks
  \item \texttt{cargo test} -- Run tests
  \item \texttt{cargo fmt} -- Format code
  \item \texttt{cargo install ---path .} -- Install binary from current project
\end{itemize}

\section{Hello, world! (Rust)}

\textbf{Create and compile with bash:}
\begin{Code}
# Create file
touch main.rs
\end{Code}
\textbf{Rust code:}
\begin{Code}
fn main() {
    println!("Hello, world!");
}
\end{Code}
\begin{Code}
# Compile with rustc
rustc main.rs

# Run the binary
./main
\end{Code}



\subsection{File Naming Convention}
\begin{itemize}
  \item \textcolor{green}{\ding{51}} \texttt{hello\_world.rs} -- Correct: snake\_case
  \item \textcolor{red}{\ding{55}} \texttt{helloworld.rs} -- Wrong: no separator
\end{itemize}

\section{Variables and Types}

\begin{Code}
fn main() {

    // Scalar types: 

    let decimal: i32 = 98_222;      // Integer
    let hex: i32 = 0xff;            // Hexadecimal
    let octal: i32 = 0o77;          // Octal
    let binary: i32 = 0b1111_0000;  // Binary
    let byte: u8 = b'A';            // Byte (u8)
    let character: char = 'R';      // Character
    %let hugging_face: char = 'ðŸ¤—'; // Unicode character

    //Compound types:

    let tuple: (i32, f64, u8) = (500, 6.4, 1);
    let (a, b, c) = tuple;
    let array: [i32; 4] = [1, 2, 3, 4];
    let first = array[0];

    // Constants:
    const MAX_POINTS: u32 = 100_000;

}
\end{Code}

\subsection{Integer Types Overview}
\begin{itemize}
    \item \textbf{Fixed-size types:} \texttt{u8/i8}, \texttt{u16/i16}, \texttt{u32/i32}, \texttt{u64/i64}, \texttt{u128/i128}
    \item \textbf{Pointer-sized types:}
    \begin{itemize}
        \item \texttt{usize}: Unsigned, size depends on architecture (4 bytes on 32-bit, 8 bytes on 64-bit)
        \item \texttt{isize}: Signed, same size rules as \texttt{usize}
    \end{itemize}
    \item \textbf{Use cases:}
    \begin{itemize}
        \item Use \texttt{usize/isize} for indexing collections and representing memory sizes
        \item Use fixed-size types (\texttt{u32/i32}, \texttt{u64/i64}) for precise control over value ranges
        \item \texttt{u64} is always 8 bytes, similar to \texttt{usize} on 64-bit systems
    \end{itemize}
\end{itemize}

\subsection{Mutability}
\begin{Code}
fn main() {
    let x = 5;     // immutable variable by default
    println!("Initial x: {}", x); // 5
    // x = x + 1;  // error: cannot assign twice to immutable variable

    let mut x = 5; // mutable variable
    println!("Initial x: {}", x); // 5
    x = x + 1;     // modify x
    println!("Modified x: {}", x); // 6
}
\end{Code}

\subsection{Shadowing}
\begin{Code}
fn main() {
    let x = 5;
    let x = x + 1; // shadows previous x
    {
        let x = x * 2; // shadows again in inner scope
        println!("Inner x: {}", x); // 12
    }
    println!("Outer x: {}", x); // 6
}
\end{Code}
\subsubsection{Shadowing vs Mutability}
\begin{Code}
fn main() {
    // using mutability
    let mut x = 5;
    x = x + 1; // modify x
    println!("Mutable x: {}", x); // 6
    // using shadowing
    let x = 5;
    let x = x + 1; // shadow previous x
    println!("Shadowed x: {}", x); // 6
}
\end{Code}
\section{Macros}
\subsection{Declarative Macros}
\begin{Code}
macro_rules! greet {
    ($name:expr) => {
        println!("Hello, {}!", $name);
    };
}
fn main() {
    greet!("Alice"); // Hello, Alice!
    greet!("Bob");   // Hello, Bob!
}
\end{Code}

\subsection{Procedural Macros}

Procedural macros work on the abstract syntax tree (AST) of Rust code.

\textbf{Types:}
\begin{itemize}
  \item \textbf{Derive macros:} \texttt{\#[derive(MyTrait)]}
  \item \textbf{Attribute macros:} \texttt{\#[my\_attribute]}
  \item \textbf{Function-like macros:} \texttt{my\_macro!(input)}
\end{itemize}

\textbf{Example: Custom Derive Macro}
\begin{Code}
// In Cargo.toml:
// [lib]
// proc-macro = true

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let name = &ast.ident;
    
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello from {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
\end{Code}

\textbf{Usage:}
\begin{Code}
trait HelloMacro {
    fn hello_macro();
}

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro(); // Hello from Pancakes!
}
\end{Code}

\section{Control Flow}
\begin{Code}
fn main() {
    let number = 6;
    if number % 2 == 0 {
        println!("{} is even", number);
    } else {
        println!("{} is odd", number);
    }
}
\end{Code}

\subsection{Combining Conditions}
\begin{Code}
fn main() {
    let number = 6;
    if number > 0 && number % 2 == 0 {
        println!("{} is a positive even number", number);
    } else if number > 0 && number % 2 != 0 {
        println!("{} is a positive odd number", number);
    } else {
        println!("{} is not positive", number);
    }
}
\end{Code}

\textbf{OR || operator}
\begin{Code}
fn main() {
    let number = 6;
    if number > 0 || number % 2 == 0 {
        println!("{} is a positive even number", number);
    } else if number > 0 || number % 2 != 0 {
        println!("{} is a positive odd number", number);
    } else {
        println!("{} is not positive", number);
    }
}
\end{Code}

\subsection{Basic Loop}
\begin{Code}
fn main() {
    let mut count = 0;
    loop {  
        count += 1;
        if count == 5 {
            break;
        }
        println!("Count: {}", count);
    }
}
\end{Code}
\subsubsection{Loop Labels}
\begin{Code}
fn main() {
    let mut count = 0;
    'outer: loop {
        count += 1;
        let mut inner_count = 0;
        loop {
            inner_count += 1;
            if inner_count == 3 {
                break 'outer; // breaks the outer loop
            }
            println!("Inner Count: {}", inner_count);
        }
        println!("Count: {}", count);
    }
}
\end{Code}

\section{For and While}
\begin{Code}
fn main() {
    let numbers = [10, 20, 30, 40, 50];
    for n in numbers.iter() {
        println!("Number: {}", n);
    }
}
\end{Code}
\begin{Code}
fn main() {
    let mut count = 0;
    while count < 5 {
        println!("Count: {}", count);
        count += 1;
    }
}
\end{Code}

\subsection {Range in For Loop}
\begin{Code}
fn main() {
    for i in 1..=5 { // inclusive range
        println!("i: {}", i);
    }
}
\end{Code}

\subsection{Break and Continue}
\begin{Code}
fn main() {
    for i in 1..10 {
        if i % 2 == 0 {
            continue; // skip even numbers
        }
        if i > 7 {
            break; // exit loop if i > 7
        }
        println!("Odd i: {}", i);
    }
}
\end{Code}

\section{Pattern Matching}
\begin{Code}
fn main() {
    let number = 3;
    match number {
        1 => println!("One"),
        2 => println!("Two"),
        3 | 4 | 5 => println!("Three, Four, or Five"),
        _ => println!("Something else"),
    }
}
\end{Code}

\textbf{Or | operator}
\begin{Code}
fn main() {
    let x = 2;
    match x {
        1 | 3 | 5 => println!("Odd"),
        2 | 4 => println!("Even"),
        _ => println!("Something else"),
    }
}
\end{Code}
\textbf{Matching Ranges}
\begin{Code}
fn main() {
    let x = 5;
    match x {
        1..=5 => println!("In range 1 to 5"),
        _ => println!("Out of range"),
    }
}
\end{Code}

\textbf{Ignoring Values with \_}
\begin{Code}
fn main() {
    let point = (3, 5);
    match point {
        (x, _) => println!("x is {}, y is ignored", x),
    }
}
\end{Code}

\section{Functions}
\begin{Code}
    fn greet(name: &str) {
        println!("Hello, {}!", name);
    }
    fn main() {
        greet("Alice");
        greet("Bob");
    } 
\end{Code}  
\subsection{Functions with Return Values}
\begin{Code}
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    fn main() {
        let sum = add(5, 10);
        println!("Sum: {}", sum);
    }
\end{Code}

\section{Statements and Expressions}
\begin{Code}
fn main() {
    let x = 5; // statement
    let y = {
        let z = 10; // statement
        z + 5      // expression
    }; // expression

    println!("x: {}, y: {}", x, y);
}
\end{Code}

\textbf{If as an Expression}
\begin{Code}
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 10 }; // if expression
    println!("The number is: {}", number);
}
\end{Code}

\textbf{match as an Expression}
\begin{Code}
fn main() {
    let number = 3;
    let result = match number {
        1 => "One",
        2 => "Two",
        3 => "Three",
        _ => "Something else",
    }; // match expression
    println!("The result is: {}", result);
}
\end{Code}


\section{Ownership and Borrowing}
\begin{Code}
fn main() {
    let s1 = String::from("hello"); // s1 owns the string
    let s2 = s1;                    // ownership moved to s2
    // println!("{}", s1);          // error: s1 is no longer valid

    let s3 = String::from("world");
    let s4 = &s3;                   // borrow s3
    println!("s3: {}, s4: {}", s3, s4); // both valid
}// s3 and s4 go out of scope here
\end{Code}

\subsection{Stack and Heap}
\begin{itemize}
  \item \textbf{Stack:} Fast, fixed-size data. FiFo structure.
  \item \textbf{Heap:} Dynamic-size data. Slower access due to indirection.
\end{itemize}
\begin{Code}
fn main() {
    let x = 5;              // stored on stack
    let s1 = String::from("hello"); // stored on heap
    let s2 = s1;           // ownership moved to s2
    // println!("{}", s1);  // error: s1 is no longer valid
    println!("x: {}, s2: {}", x, s2);
} // x and s2 go out of scope here and memory is freed
\end{Code}


\subsection{String Type}
\textbf{String Literals:} immutable, fixed-size, stored on stack, example:
\begin{Code}    
let s: &str = "Hello, world!"; // string slice (immutable)
\end{Code}

\textbf{String Type:} mutable, growable, stored on heap, example:
\begin{Code}
let mut s = String::from("Hello"); // String type (mutable)
\end{Code}

\subsection{Ownership and Scope}
\begin{Code}
fn main() {
    {
        let s = String::from("hello"); // s is valid here
        println!("{}", s);
    } // s goes out of scope and memory is freed here
}
\end{Code}

\subsection{Move}
\textbf{moving with integers:}
\begin{Code}
fn main() {
    let x = 5;
    let y = x; // x is moved to y - Copy trait for integers
    // println!("{}", x); // error: x is no longer valid
    println!("{}", y);
}
\end{Code}

\textbf{moving with String:}
\begin{Code}
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 is moved to s2 - ownership transferred
    // println!("{}", s1); // error: s1 is no longer valid
    println!("{}", s2);
}
\end{Code}

\textbf{Notes:} When you create a String, the actual string struct itself is stored on the stack, but the contents (the characters) are stored on the heap. When you move a String, you are transferring ownership of the heap data to the new variable.
\textbf{Shallow Copy} means copying only the pointer to the data, not the data itself. In Rust, moving a String is like a shallow copy because the ownership of the heap data is transferred to the new variable, and the original variable can no longer access it.

\subsection{Copy vs Clone}

\begin{center}
\begin{tabular}{|p{4cm}|p{4cm}|}
\hline
\textbf{\textcolor{orange!80!red}{Copy}} & \textbf{\textcolor{purple!60!blue}{Clone}} \\
\hline
The bits are copied exactly (\textbf{shallow copy}) & The actual data on the heap is duplicated (\textbf{deep copy}) \\
\hline
Only types that do not manage heap-allocated memory can implement Copy & Necessary for types that manage resources that need to be separately owned, like String \\
\hline
\end{tabular}
\end{center}

\textbf{Example:}
\begin{Code}
fn main() {
    // Copy trait (implicit)
    let x = 5;
    let y = x; // x is copied to y
    println!("x: {}, y: {}", x, y); // both valid
    
    // Clone trait (explicit)
    let s1 = String::from("hello");
    let s2 = s1.clone(); // explicit clone
    println!("s1: {}, s2: {}", s1, s2); // both valid
}
\end{Code}

\subsection{Passing Ownership to Functions}
\begin{Code}
fn takes_ownership(s: String) {
    println!("{}", s);
} // s goes out of scope and memory is freed here
fn main() {
    let s = String::from("hello");
    takes_ownership(s); // ownership moved to function
    // println!("{}", s); // error: s is no longer valid
}
\end{Code}
\subsection{Returning Ownership from Functions}
\begin{Code}
fn gives_ownership() -> String {
    let s = String::from("hello");
    s // ownership moved to caller
}

fn takes_and_gives_back(s: String) -> String {
    s // ownership moved back to caller
}

fn main() {
    let s = gives_ownership(); // ownership moved to s

    println!("{}", s);
}
\end{Code}

\subsection{References and Borrowing}
\begin{itemize}
    \item \textbf{Pointer:} A variable that stores the memory address of another variable.
    \item \textbf{Reference:} Acts like a pointer to the value it references, but it is guaranteed to always be valid and cannot be null. References are created using the \& symbol.
    \begin{itemize}
        \item \texttt{Immutable references:} \texttt{\&T} allows you to borrow a value without taking ownership and modifying it.
        \item \texttt{Mutable references:} \texttt{\&mut T} allows you to borrow a value and modify it. We can have only one mutable reference to a particular piece of data in a particular scope.
    \end{itemize}
\end{itemize}


\subsection{Rules of References}
At any given time,
\begin{itemize}
    \item you can have either one mutable reference 
    \item or any number of immutable references.
\end{itemize}

Single Mutable Reference Allowed:
\begin{Code}
fn main() {
    let mut s = String::from("hello");
    let r1 = &mut s; // first mutable reference
    // let r2 = &mut s; // error: second mutable reference not allowed
    r1.push_str(", world");
    println!("{}", r1);

    // let r2 = &mut s; // error: second mutable reference not allowed
}
\end{Code}

\subsection{The Slice Type}
\begin{itemize}
    \item Allows to reference parts of a collection without copying data.
    \item Slices are references with bound checking, ensuring memory outside the slice is not accessed.
\end{itemize}

\begin{Code}
fn main() {
    let s = String::from("hello world");
    let hello = &s[0..5]; // slice for "hello"
    let world = &s[6..11]; // slice for "world"
    println!("{} {}", hello, world);
}
\end{Code}

\textbf{Rules for Slices}
\begin{itemize}
    \item Slice must always point to a valid data.
    \item One mutable slice or any number of immutable slices allowed at a time.
    \item Combining mutable and immutable slices is not allowed until all references go out of scope.
\end{itemize}

\section{Collections}
\subsection{Structs}
\begin{Code}
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: String::from("user1@example.com"),
        username: String::from("user1"),
        sign_in_count: 1,
        active: true,
    };
    println!("Username: {}", user1.username);
}
\end{Code}


\subsubsection{Debug Trait}
\begin{Code}
#[derive(Debug)]
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn main() {
    let user1 = User {
        email: String::from("user1@example.com"),
        username: String::from("user1"),
        sign_in_count: 1,
        active: true,
    };
    println!("User1: {:?}", user1);
}
\end{Code}

\subsubsection{Methods}
\begin{Code}
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect = Rectangle { width: 10, height: 5 };
    println!("Area: {}", rect.area());
}
\end{Code}

\subsubsection{Mutable Methods}
Mutable methods are similar to regular methods, but they take a mutable reference to self (\&mut self) instead of an immutable reference (\&self). This allows the method to modify the instance it is called on.
\begin{Code}
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Self {
        Counter { count: 0 }
    }

    fn increment(&mut self) {
        self.count += 1;
    }

    fn get_count(&self) -> u32 {
        self.count
    }
}

fn main() {
    let mut counter = Counter::new();
    counter.increment();
    println!("Count: {}", counter.get_count());
}
\end{Code}

\subsection{Enums}
An enum is like a list of possible values. Each value in the enum is called a variant.
\begin{Code}
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
fn main() {
    let msg = Message::Write(String::from("Hello"));
    match msg {
        Message::Quit => println!("Quit message"),
        Message::Move { x, y } => println!("Move to ({}, {})", x, y),
        Message::Write(text) => println!("Write message: {}", text),
        Message::ChangeColor(r, g, b) => println!("Change color to RGB({}, {}, {})", r, g, b),
    }
}
\end{Code}

\subsubsection{Option<T>}
\begin{itemize}
    \item Represents an optional value: every Option is either \texttt{Some(value)} and contains a value, or \texttt{None}, and does not.
    \item Used to handle cases where a value may be absent without using null.
    \item Helps avoid runtime errors related to null references.
\end{itemize}

\begin{Code}
fn main() {
    let some_number: Option<i32> = Some(5);
    let no_number: Option<i32> = None;
}
\end{Code}

\subsubsection{Result<T, E>}
\begin{itemize}
    \item Represents either success (\texttt{Ok(value)}) or failure (\texttt{Err(error)}).
    \item Used for error handling in Rust.
\end{itemize}
\begin{Code}
fn divide(dividend: f64, divisor: f64) -> Result<f64, String> {
    if divisor == 0.0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(dividend / divisor)
    }
}
fn main() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
\end{Code}

\section{Vectors}
\begin{Code}
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // new method to create an empty vector
    //
    //let mut numbers: Vec<i32> = Vec::new();

    for n in &numbers { println!("{n}"); }

    match numbers.get(10) {
        Some(x) => println!("found: {x}"),
        None => println!("none"),
    }

    // Accessing elements directly
    let first = numbers[0];
    println!("First element: {}", first);
    let second = &numbers[1];
    println!("Second element: {}", second);

    // Accessing elements safely
    if let Some(value) = numbers.get(2) {
        println!("Element at index 2: {}", value);
    } else {
        println!("No element at index 2");
    }

    // Adding elements
    numbers.push(6);

    // Removing elements
    let last = numbers.pop();

    // Inserting elements
    numbers.insert(2, 1); // insert 1 at index 2

    // Removing elements by index
    numbers.remove(3); // remove element at index 3

    // iterating with indices
    for (index, value) in numbers.iter().enumerate() {
        println!("Index: {}, Value: {}", index, value);
    }
}
\end{Code}

\textbf{Notes:}
\begin{itemize}
    \item Vectors are heap-allocated, growable arrays.
    \item Use \texttt{vec![]} macro to create vectors.
    \item Use \texttt{push} to add elements, \texttt{pop} to remove the last element.
    \item Access elements using indexing or \texttt{get} method for safe access.
    \item iter method returns an iterator over references to the elements of the vector.
    \item iter\_mut method returns an iterator that allows modifying each element.
    \item into\_iter method consumes the vector and returns an iterator that yields owned elements
    \item enumerate method returns an iterator that yields pairs of index and reference to the element.
\end{itemize}

\subsection{Common Vector Methods}
\begin{itemize}
    \item \texttt{len()} - Returns the number of elements in the vector.
    \item \texttt{is\_empty()} - Checks if the vector is empty.
    \item \texttt{clear()} - Removes all elements from the vector.
    \item \texttt{remove(index)} - Removes the element at the specified index.
    \item \texttt{contains(\&value)} - Checks if the vector contains a specific value.
    \item \texttt{sort()} - Sorts the elements of the vector in ascending order.
    \item \texttt{reverse()} - Reverses the order of elements in the vector.
    \item \texttt{extend(iterable)} - Extends the vector by appending elements from an iterable.
\end{itemize}

\section{Hashmap}
\begin{itemize}
    \item HashMap is a collection that stores key-value pairs.
    \item Keys must be unique and implement the \texttt{Eq} and \texttt{Hash} traits.
    \item Values can be of any type.
\end{itemize}

\begin{Code}
use std::collections::HashMap;
fn main() {
    // Creating a new HashMap
    let mut scores = HashMap::new();

    // Inserting key-value pairs
    scores.insert(String::from("Alice"), 10);
    scores.insert(String::from("Bob"), 20);

    // Accessing values
    if let Some(score) = scores.get("Alice") {
        println!("Alice's score: {}", score);
    }

    // Iterating over key-value pairs
    for (name, score) in &scores {
        println!("{}: {}", name, score);
    }

    // Updating values
    scores.entry(String::from("Alice")).and_modify(|e| *e += 5).or_insert(10);

    // Removing a key-value pair
    scores.remove("Bob");

    // Create a HashMap from a iterator
    let teams = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];
    let scores: HashMap<_, _> = teams.into_iter().zip(initial_scores.into_iter()).collect();

    println!("{:?}", scores);
}
\end{Code}

\subsection{Common HashMap Methods}
\begin{itemize}
    \item len() - Returns the number of elements in the HashMap.
    \begin{Code}
    let mut map = HashMap::new();
    map.insert("key1", 10);
    map.insert("key2", 20);
    println!("Length: {}", map.len()); // Length: 2
    \end{Code}
    \item is\_empty() - Checks if the HashMap is empty.
    \begin{Code}
    let map: HashMap<&str, i32> = HashMap::new();
    println!("Is empty: {}", map.is_empty()); // Is empty: true
    \end{Code}
    \item remove(\&key) - Removes the key-value pair for the specified key.
    \begin{Code}
    let mut map = HashMap::new();
    map.insert("key1", 10);
    map.remove("key1");
    println!("Length after removal: {}", map.len()); // Length after removal: 0
    \end{Code}
    \item contains\_key(\&key) - Checks if the HashMap contains the specified
    \begin{Code}
    let mut map = HashMap::new();
    map.insert("key1", 10);
    println!("Contains key1: {}", map.contains_key("key1")); // Contains key1
    \end{Code}
\end{itemize}


\section{Errors}
\textbf{panic!} macro is used to indicate unrecoverable errors in Rust. When called, it stops the normal execution of the program and starts unwinding the stack, cleaning up resources along the way.
\begin{Code}
fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Division by zero is not allowed");
    }
    a / b
}
\end{Code}
\subsection{Creating Custom Error Types}

\begin{Code}
use std::fmt;

#[derive(Debug)]
enum MyError {
  NotFound,
  InvalidInput,
  ConnectionError,
}

impl fmt::Display for MyError {
  fn fmt(&self, f: &mut fmt::Firmatter) -> fmt::Result {
    match self {
      MyError::NotFound => write!(f, "Resource not found"),
      MyError::InvalidInput => write!(f, "Invalid input provided"),
      MyError::ConnectionError => write!(f, "Connection error occurred"),
    }
  }
}
\end{Code}


\subsection{Logging}

The `log` crate provides a lightweight logging facade. To use it:

\begin{Code}
use log::{info, warn, error, debug};

fn main() {
    env_logger::init();
    info!("Starting application");^
    warn!("Low disk space");
    error!("Failed to connect to database");
    debug!("Debugging information");
}
\end{Code}

The slog crate is another popular logging library that provides more features and flexibility.

\begin{Code}
use slog::{Drain, Logger, o, info};
use slog_async;
use slog_term;

fn main() {
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::CompactFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let log = Logger::root(drain, o!());

    info!(log, "Application started");
}
\end{Code}

\section{Crates, Packages and Modules}

\begin{itemize}
    \item \textbf{Crate:} A binary or library. The smallest unit of code distribution in Rust.
    \begin{itemize}
        \item \textbf{Binary Crate:} Produces an executable. Contains a \texttt{main} function. cargo new --bin my\_app
        \item \textbf{Library Crate:} Provides functionality to be used by other crates. Does not have a \texttt{main} function. cargo new --lib my\_lib
    \end{itemize}
    \item \textbf{Package:} A bundle of one or more crates. Managed by Cargo.
    \item \textbf{Module:} A way to organize code within a crate. Can contain functions, structs, enums, etc.
\end{itemize}

\subsection{Module Organization with mod.rs}

\textbf{Project Structure:}
\begin{Code}
src/
  main.rs
  network/
    mod.rs        // Module root
    server.rs     // Submodule
    client.rs     // Submodule
\end{Code}

\textbf{network/mod.rs:}
\begin{Code}
// Declare submodules
pub mod server;
pub mod client;

// Re-export commonly used items
pub use server::Server;
pub use client::Client;

// Module-level function
pub fn connect() {
    println!("Connecting...");
}
\end{Code}

\textbf{network/server.rs:}
\begin{Code}
pub struct Server {
    pub address: String,
}

impl Server {
    pub fn new(addr: String) -> Self {
        Server { address: addr }
    }
    
    pub fn start(\&self) {
        println!("Server starting at {}", 
                 self.address);
    }
}
\end{Code}

\textbf{network/client.rs:}
\begin{Code}
pub struct Client {
    pub name: String,
}

impl Client {
    pub fn new(name: String) -> Self {
        Client { name }
    }
    
    pub fn connect(\&self) {
        println!("{} connecting...", self.name);
    }
}
\end{Code}

\textbf{main.rs:}
\begin{Code}
mod network;

fn main() {
    // Using re-exported items
    let server = network::Server::new(
        "127.0.0.1:8080".to_string()
    );
    server.start();
    
    // Direct module access
    let client = network::client::Client::new(
        "Alice".to_string()
    );
    client.connect();
    
    // Module function
    network::connect();
}
\end{Code}

\section{Debugging}

% Now, I m writing my own cheatsheet content below

\part{ADVANCED CONCEPTS}

\section{Generics}

\subsection{Generic functions}

\begin{Code}

  fn first_element<T>(list: &[T]) -> Option<&T> {
      if list.is_empty() {
          None
      } else {
          Some(&list[0])
      }
  }

  fn main() {
      let numbers = vec![1, 2, 3];
      let words = vec!["hello", "world"];
      
      if let Some(first_num) = first_element(&numbers) {
          println!("First number: {}", first_num);
      }
      
      if let Some(first_word) = first_element(&words) {
          println!("First word: {}", first_word);
      }
  }
\end{Code}

\subsection{Generic structs}

\begin{Code}
  struct Point<T> {
      x: T,
      y: T,
      z: i32,
  }

  impl<T> Point<T> {
      fn new(x: T, y: T, z: i32) -> Self {
          Point { x, y, z }
      }
  }

  fn main() {
      let int_point = Point::new(1, 2, 3);
      let float_point = Point::new(1.0, 2.0, 3.0);
      
      println!("Integer Point: ({}, {}, {})", int_point.x, int_point.y, int_point.z);
      println!("Float Point: ({}, {}, {})", float_point.x, float_point.y, float_point.z);
  }
\end{Code}

\subsection{Generic Enums}

\begin{Code}
  enum Option<T> {
      Some(T),
      None,
  }

  fn main() {
      let some_number = Option::Some(5);
      let no_number: Option<i32> = Option::None;
      
      match some_number {
          Option::Some(value) => println!("Got a number: {}", value),
          Option::None => println!("No number"),
      }
      
      match no_number {
          Option::Some(value) => println!("Got a number: {}", value),
          Option::None => println!("No number"),
      }
  }
\end{Code}

\subsection{Notes:}
\begin{itemize}
  \item Using generics doesnt slow down your code. The compiler generates optimized versions for each type used.
  \item Monomorphization is the process of generating specific implementations for each type used with generics.
  \item Monomorphization happens at compile time, so there is no runtime overhead.
\end{itemize}



\section{Traits}

\begin{itemize}
  \item Traits define shared behavior across types.
  \item A trait is like a contract that types can implement.
  \item Traits enable polymorphism and code reuse.
\end{itemize}

\subsection{Defining and Implementing Traits}
\begin{Code}
  pub trait Summary {
      fn summarize(&self) -> String {
          String::from("(Read more...)") // default implementation
      }
  }

  struct NewsArticle {
      headline: String,
      location: String,
      content: String,
  }

  impl Summary for NewsArticle {
      fn summarize(&self) -> String {
          format!("{} - {}", self.headline, self.location)
      }
  }
  struct Tweet {
      username: String,
      content: String,
      reply: bool,
      retweet: bool,
  }
  impl Summary for Tweet {
      fn summarize(&self) -> String {
          format!("{}: {}", self.username, self.content)
      }
  }
  fn main() {
      let article = NewsArticle {
          headline: String::from("Rust is awesome!"),
          location: String::from("Internet"),
          content: String::from("Rust is a systems programming language..."),
      };
      let tweet = Tweet {
          username: String::from("user123"),
          content: String::from("Hello, world!"),
          reply: false,
          retweet: false,
      };
      println!("Article Summary: {}", article.summarize());
      println!("Tweet Summary: {}", tweet.summarize());
  }
\end{Code}

\subsubsection{Polymorphism}

A function that accepts any type implementing a trait.
Using traits as function parameters:

\begin{Code}
  fn notify(item: &impl Summary) {
      println!("Breaking news! {}", item.summarize());
  }

  fn main() {
      let article = NewsArticle {
          headline: String::from("Rust is awesome!"),
          location: String::from("Internet"),
          content: String::from("Rust is a systems programming language..."),
      };
      let tweet = Tweet {
          username: String::from("user123"),
          content: String::from("Hello, world!"),
          reply: false,
          retweet: false,
      };
      notify(&article);
      notify(&tweet);
  }
\end{Code}

\subsubsection{Trait Bounds and Generics}

Using trait bounds in generic functions:
\begin{Code}
  fn notify<T: Summary>(item: &T) {
      println!("Breaking news! {}", item.summarize());
  }
\end{Code}


\section{Lifetimes}


Lifetimes manage how long references are valid to prevent dangling references.

\begin{itemize}
    \item Ensure references do not outlive the data they point to.
    \item Specified using apostrophes (e.g., \texttt{'a}).
    \item Prevents references from pointing to invalid data.
\end{itemize}

\begin{Code}
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    
    fn main() {
        let string1 = String::from("long string");
        let string2 = "short";
    
        let result = longest(string1.as_str(), string2);
        println!("The longest string is {}", result);
    }
\end{Code}
\subsection{Lifetime Annotations in Structs}
\begin{Code}
    struct ImportantExcerpt<'a> {
        part: &'a str,
    }
    
    fn main() {
        let novel = String::from("Call me Ishmael. Some years ago...");
        let first_sentence = novel.split('.').next().expect("Could not find a '.'");
        let excerpt = ImportantExcerpt { part: first_sentence };
        println!("Excerpt: {}", excerpt.part);
    }
\end{Code}

\subsubsection{Lifetime Elision}
Rust applies three rules to infer lifetimes when they are not explicitly annotated:
\begin{itemize}
    \item Each parameter that is a reference gets its own lifetime parameter.
    \item If there is exactly one input lifetime parameter, that lifetime is assigned to all output
    reference parameters.
    \item If there are multiple input lifetime parameters, but one of them is \texttt{\&self} or \texttt{\&mut self}, the lifetime of \texttt{self} is assigned to all output reference parameters.
\end{itemize}
\begin{Code}
    fn first_word(s: &str) -> &str {
        let bytes = s.as_bytes();
    
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &s[0..i];
            }
        }
    
        &s[..]
    }
\end{Code}

\subsubsection{Static Lifetimes}

Static lifetimes are the longest possible lifetimes in Rust. They last for the entire duration of the program. They are stored in the binary's read-only memory.

\begin{Code}
    fn main() {

        // A string literal has a 'static lifetime
        let s: &'static str = "I have a static lifetime.";


        // Global variable with 'static lifetime
        static GLOBAL_VAR: &str = "I am a global variable with a static lifetime.";

    }
\end{Code}

\section{Smart Pointers}
Smart pointers are data structures that not only act like a pointer but also have additional metadata and capabilities.
It extends the Rust ownership system to enable more complex memory management patterns.

\textbf{Single ownership with Box<T>}:
\begin{Code}
    fn main() {
        // Box allocates data on heap
        let b = Box::new(5);
        // Dereference with *
        println!("b = {}", b);
        // b is dropped and heap memory freed
    }
\end{Code}

\textbf{Shared ownership with Rc<T>}:
\begin{Code}
    use std::rc::Rc;

    fn main() {
        // Rc enables multiple owners
        let a = Rc::new(5);
        // Clone the Rc, not the data
        let b = Rc::clone(&a);
        // Both a and b can access the data
        println!("a = {}, b = {}", a, b);
    }
\end{Code}

\textbf{Mutable shared ownership with RefCell<T>}:
\begin{Code}
    use std::cell::RefCell;
    fn main() {
        // RefCell allows interior mutability
        let data = RefCell::new(5);
        {
            // borrow_mut for mutable access
            let mut value = data.borrow_mut();
            *value += 1; // modify through reference
        } // mutable borrow ends here
        // borrow for immutable access
        println!("data = {}", data.borrow());
    }
\end{Code}



\end{document}
